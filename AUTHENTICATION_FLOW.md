# Complete Authentication & Authorization Flow

This document explains the complete flow of authentication and authorization in the PM Assist API.

## Overview

The system uses a **dual-token architecture**:
1. **Azure Entra ID JWT Token** - Validates user identity (external, from Microsoft)
2. **PMA Token** - Custom token containing workspace roles (internal, generated by our API)

---

## Phase 1: Initial Authentication (Login)

### Endpoint: `POST /auth/validate`

**Request:**
```http
POST /auth/validate
Authorization: Bearer <azure-entra-id-token>
```

**Flow:**

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Client sends Azure Entra ID JWT token                    │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. AzureJWTValidator.validate_token()                       │
│    - Fetches signing keys from Azure JWKS endpoint           │
│    - Validates token signature (RS256)                      │
│    - Verifies audience and issuer                           │
│    - Checks expiration                                       │
│    - Extracts: user_id, email, display_name                 │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. TokenService.validate_azure_token_and_generate_pma()      │
│    Step 3.1: Query database for user's workspace roles      │
│    - Executes: SELECT workspace_id, role                    │
│                FROM WorkspaceMember                          │
│                WHERE user_id = ?                             │
│    - Returns: {workspace_id: role, ...}                     │
│    - If new user: returns {} (empty dict)                   │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Generate PMA Token                                        │
│    - Payload: {                                              │
│        user_id: "...",                                       │
│        email: "...",                                         │
│        roles: {workspace_id: "OWNER", ...},                 │
│        exp: <expiry_time>,                                   │
│        iat: <issued_time>                                    │
│      }                                                       │
│    - Signed with: HS256 (symmetric key)                      │
│    - Secret: PMA_TOKEN_SECRET from .env                     │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. Response                                                  │
│    {                                                         │
│      "user_id": "...",                                      │
│      "email": "...",                                        │
│      "display_name": "...",                                 │
│      "pma_token": "<jwt-token>",                           │
│      "roles": {workspace_id: "OWNER", ...}                  │
│    }                                                         │
└─────────────────────────────────────────────────────────────┘
```

**Key Points:**
- Roles are **always fetched from database** after Azure token validation
- If user has no workspaces, `roles: {}` (empty dict)
- PMA token contains the roles at the time of generation

---

## Phase 2: Accessing Protected Resources

### Request Format

**All protected endpoints require both tokens:**
```http
GET /workspaces/{workspace_id}
Authorization: Bearer <azure-token>
X-PMA-Token: <pma-token>
```

### Flow Through AuthMiddleware

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Request arrives at AuthMiddleware                       │
│    - Checks if path is excluded (e.g., /docs, /health)      │
│    - If excluded → skip auth, proceed                      │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Extract Tokens from Headers                             │
│    - Authorization header → Azure token                    │
│    - X-PMA-Token header → PMA token                         │
│    - If missing → 401 Unauthorized                          │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Validate Azure Token                                     │
│    - Same validation as Phase 1                            │
│    - If invalid → 401 Unauthorized                          │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Validate PMA Token                                       │
│    - Decode with PMA_TOKEN_SECRET                           │
│    - Check expiration                                       │
│    - Extract: user_id, email, roles                         │
│    - If invalid → 401 Unauthorized                         │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. Verify Token User Match                                  │
│    - Compare user_id from Azure token                       │
│    - Compare user_id from PMA token                         │
│    - If mismatch → 401 Unauthorized                         │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. Extract Workspace ID from URL Path                      │
│    - Parse: /workspaces/{workspace_id}/...                  │
│    - Look up role in PMA token's roles dict                │
│    - If role not found in token:                            │
│      → Query database for fresh roles                       │
│      → Update roles dict                                    │
│      → Look up role again                                   │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. Attach User Context to Request                           │
│    request.state.user = CurrentUserContext(                 │
│      user_id=...,                                           │
│      email=...,                                             │
│      roles={...},                                           │
│      role_for_workspace="OWNER"                            │
│    )                                                        │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 8. Request proceeds to endpoint handler                     │
└─────────────────────────────────────────────────────────────┘
```

---

## Phase 3: Role-Based Authorization

### Endpoint Dependency: `require_role()`

**Usage in endpoints:**
```python
@router.get("/workspaces/{workspace_id}")
async def get_workspace(
    workspace_id: str,
    user: CurrentUserContext = Depends(require_role("VIEWER"))
):
    # user.role_for_workspace is guaranteed to be at least "VIEWER"
    ...
```

**Role Hierarchy:**
```
VIEWER (0) < MEMBER (1) < ADMIN (2) < OWNER (3)
```

**Flow:**

```
┌─────────────────────────────────────────────────────────────┐
│ 1. require_role() dependency executes                      │
│    - Checks request.state.user exists                       │
│    - If missing → 401 Unauthorized                         │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Check if user has role for workspace                     │
│    - If role_for_workspace is None → 403 Forbidden         │
│    - User not a member of this workspace                    │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Check role level                                         │
│    - Get user's role level (0-3)                           │
│    - Get required role level (0-3)                          │
│    - If user level < required level → 403 Forbidden        │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Return user context                                      │
│    - User has sufficient permissions                        │
│    - Endpoint handler can proceed                           │
└─────────────────────────────────────────────────────────────┘
```

---

## Phase 4: Token Refresh Scenarios

### Scenario 1: Manual Token Refresh

**Endpoint:** `POST /auth/refresh`

**When to use:**
- User wants to update their token with latest roles
- After creating/joining a workspace
- After role changes

**Flow:**
```
1. Validate Azure token
2. Validate current PMA token
3. Verify user_id matches
4. Fetch fresh roles from database
5. Generate new PMA token with updated roles
6. Return new token
```

---

### Scenario 2: Automatic Token Refresh (After Role Changes)

**When roles change, endpoints automatically return refreshed tokens:**

#### A. Create Workspace
```
POST /workspaces
→ Workspace created
→ User added as OWNER in database
→ Fresh roles fetched from database
→ New PMA token generated
→ Response includes: {..., "pma_token": "<new-token>"}
```

#### B. Add Member
```
POST /workspaces/{id}/members
→ Member added to database
→ If added user == current user:
  → Fresh roles fetched
  → New PMA token generated
  → Response includes: {..., "pma_token": "<new-token>"}
```

#### C. Change Role
```
PATCH /workspaces/{id}/members/{member_id}/role
→ Role updated in database
→ If changed user == current user:
  → Fresh roles fetched
  → New PMA token generated
  → Response includes: {..., "pma_token": "<new-token>"}
```

#### D. Remove Member
```
DELETE /workspaces/{id}/members/{member_id}
→ Member removed from database
→ If removed user == current user:
  → Fresh roles fetched (workspace removed from roles)
  → New PMA token generated
  → Response includes: {..., "pma_token": "<new-token>"}
```

---

## Phase 5: Automatic Role Refresh in Middleware

**Fallback mechanism:**

If a user's PMA token has empty roles `{}`, but they try to access a workspace:

```
1. Middleware extracts workspace_id from URL
2. Looks up role in token → Not found (roles: {})
3. Automatically queries database for fresh roles
4. Updates roles dict with fresh data
5. Looks up role again → Found!
6. Proceeds with request
```

This handles edge cases where:
- User was just added to a workspace
- Token was generated before workspace membership
- Database was unavailable during initial token generation

---

## Complete Request Flow Diagram

```
┌──────────────┐
│   Client     │
└──────┬───────┘
       │
       │ POST /auth/validate
       │ Authorization: Bearer <azure-token>
       ▼
┌─────────────────────────────────────┐
│  AzureJWTValidator                  │
│  - Validates Azure token            │
│  - Extracts user info               │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Database Query                     │
│  - get_user_workspace_roles()       │
│  - Returns: {workspace_id: role}   │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Generate PMA Token                 │
│  - Embed roles in token            │
└──────────────┬──────────────────────┘
               │
               │ Response: {pma_token, roles}
               ▼
┌──────────────┐
│   Client     │
└──────┬───────┘
       │
       │ GET /workspaces/{id}
       │ Authorization: Bearer <azure-token>
       │ X-PMA-Token: <pma-token>
       ▼
┌─────────────────────────────────────┐
│  AuthMiddleware                     │
│  - Validates both tokens            │
│  - Extracts workspace_id            │
│  - Looks up role                    │
│  - (Auto-refresh if needed)        │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  require_role("VIEWER")              │
│  - Checks role level                │
│  - Validates permissions             │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Endpoint Handler                   │
│  - request.state.user available     │
│  - Business logic executes          │
└──────────────┬──────────────────────┘
               │
               │ Response
               ▼
┌──────────────┐
│   Client     │
└──────────────┘
```

---

## Security Considerations

1. **Azure Token Validation:**
   - Always validates signature using Azure's public keys
   - Verifies audience and issuer
   - Checks expiration

2. **PMA Token Security:**
   - Signed with secret key (HS256)
   - Contains expiration time
   - User_id must match Azure token

3. **Role Validation:**
   - Roles are always fetched from database (source of truth)
   - Token roles are used for performance (caching)
   - Database is checked if token roles are missing

4. **Token Refresh:**
   - Requires both Azure and PMA tokens
   - Validates both before refreshing
   - Ensures user_id matches

---

## Token Lifecycle

```
┌─────────────────────────────────────────────────────────┐
│ Initial Login                                            │
│ - Azure token validated                                 │
│ - Roles fetched from DB                                 │
│ - PMA token generated with roles                         │
└────────────────────┬────────────────────────────────────┘
                     │
                     │ PMA token expires after X hours
                     │ (configurable via PMA_TOKEN_EXPIRY_HOURS)
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│ Token Refresh                                            │
│ - Azure token still valid                               │
│ - PMA token expired or roles changed                    │
│ - Fresh roles fetched from DB                           │
│ - New PMA token generated                               │
└─────────────────────────────────────────────────────────┘
```

---

## Error Scenarios

### 401 Unauthorized
- Missing Azure token
- Missing PMA token
- Invalid/expired Azure token
- Invalid/expired PMA token
- Token user mismatch

### 403 Forbidden
- User not a member of workspace
- User role level insufficient
- No role found for workspace

---

## Summary

1. **Login:** Azure token → Validate → Fetch roles → Generate PMA token
2. **Request:** Both tokens → Validate → Extract roles → Check permissions
3. **Refresh:** Both tokens → Validate → Fetch fresh roles → New PMA token
4. **Auto-refresh:** Role changes → Endpoint returns new token
5. **Fallback:** Missing roles in token → Query database automatically

The system ensures roles are always current by:
- Fetching from database during token generation
- Refreshing tokens when roles change
- Auto-refreshing from database if token roles are missing

